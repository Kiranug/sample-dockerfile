trigger: none

parameters:
  - name: environment
    displayName: "Select Environment"
    type: string
    default: "dev"
    values:
      - dev
      - qa
      - uat
      - prod

  - name: useExistingImage
    displayName: "Do you want to use an existing image?"
    type: boolean
    default: false

  - name: existingImage
    displayName: "Provide the full image name (if using an existing image)"
    type: string
    default: ""

variables:
  - group: dev-variables  # Linking the variable group
  - name: dockerfilePath
    value: '$(Build.SourcesDirectory)/Dockerfile'
  - name: tag
    value: '$(Build.BuildId)'
  - name: IMAGE_REPOSITORY
    value: '$(Build.Repository.Name)'
  - name: FINAL_IMAGE
    value: $[coalesce(variables['existingImage'], format('{0}:{1}', variables['IMAGE_REPOSITORY'], variables['tag']))]

stages:

- stage: BuildAndPush
  displayName: Build and Push Docker Image
  condition: eq('${{ parameters.useExistingImage }}', false)
  jobs:
  - job: Build
    displayName: Build and Push Docker Image to ACR
    steps:
    - task: Docker@2
      displayName: Build and Push Docker Image
      inputs:
        command: buildAndPush
        repository: $(IMAGE_REPOSITORY)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)  # Now fetched from variable group
        tags: |
          $(tag)

- stage: DeployToAKS
  displayName: Deploy to AKS (${{ parameters.environment }})
  jobs:
  - job: Deploy
    displayName: Deploy to AKS
    steps:

    - script: |
        echo "Final Image: $(FINAL_IMAGE)"
      displayName: 'Verify Image Name'

    - task: KubernetesManifest@1
      displayName: Deploy to AKS
      inputs:
        action: 'deploy'
        connectionType: 'kubernetesServiceConnection'
        kubernetesServiceConnection: $(K8S_SERVICE_CONNECTION)  # Now fetched from variable group
        manifests: |
          $(Build.SourcesDirectory)/manifests/deployment.yaml
